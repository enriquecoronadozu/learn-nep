{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"What is NEP? Node Primitives (NEP) is a high-level library that provides simple and re-usable tools that enable the generation of software architectures for Human-Robot Interaction (HRI) and End-User Development (EUD). NEP is user-friendly : It was designed to be ease-to-install, ease-to-use and ease-to-learn. NEP is reusable : It enables the reuse of code and bridge between different middlewares. NEP is cross-platform : It can be used in Windows, Mac, Linux, Android and iOS. NEP is mainly a inter-process communication library using sockets. NEP is back-ended by ROS , ROS 2.0 and expand capabilities of ZeroMQ and nanomsg to enable ROS-like features and cross-platform software architectures for robotics. Deafult back-end implementation of NEP is ZeroMQ , which enable more user-friendly installation and provides better support for newer and older versions of most used desktop operating systems (Windows and MacOSX). 1.- Pre-requirements For use Nao, Pepper and ROS-based robot it is required to have Python 2 installed. For Tensor Flow applications in Windows it is required to have Python 3 .\u3000 Tensorflow in OSX and Ubuntu can use either Python 2 or Python 3. Recomended way to install Python 2 on Windows and OSX See tutorial Recomended way to install Python 3 on Windows and OSX See tutorial 2.- Install NEP Discovery Server Installer for windows Installer for OSX Installer for Ubuntu Source code (developers) 3.- Minimal installation using pip If you only have one version of Python (2 or 3) installed pip install nep pip install tornado For Python 2 also install: pip install trollius For Python 3 also install: pip install asyncio If you are in Windows and you have both Python 2 and Python 3 installed For Python 2: py -2 -m pip install -U nep py -2 -m pip install -U trollius py -2 -m pip install -U tornado For Python 3: py -3 -m pip install -U nep py -3 -m pip install -U asyncio py -3 -m pip install -U tornado If you are in OSX or Ubuntu and you have both Python 2 and Python 3 installed For Python 2: python2 -m pip install -U nep python2 -m pip install -U trollius python2 -m pip install -U tornado For Python 3: python3 -m pip install -U nep python3 -m pip install -U asyncio python3 -m pip install -U tornado 4.- Advanced installation methods 4.1 Aditional back-end options Defaul back-end solution of NEP is ZeroMQ which is installed by default, therefore not additional effort is needed to start to used it. The next table describes the installation complexity of other back-ends supported by NEP. Middleware Windows Linux Mac OS X Drawbacks nanomsg Very Very complex Very complex Binaries must be compiled ROS N.A Complex N.A Not fully support in Windows and Mac OS X ROS 2.0 Very complex Complex Complex Suported only in Windows 10 and few versions of Mac OS X NEP using ZeroMQ as back-end have been tested with success in Windows 7, 8, 8.1 and 10, Ubuntu 14, 16 and 18, as well as Mac OS X including the lastest version, Mojave (10.14). 4.1.1 ROS Follow the steps of ROS official documentation ROS installation details 4.1.2 ROS 2.0 Follow the steps of ROS 2.0 official documentation ROS 2.0 installation details 4.1.3 Nanomsg Pre-compiled binaries for Windows - download here 4.2 Github 4.2.1 Old version (0.1) NEP Beta version (warning: older version with different API and less capabilities): Link to older version 4.2.2 Current version (1.0) Link to current version 5.- References Version 0.1 of NEP BibTeX: @incollection{coronado2019design, title={Design of a Human-Centered Robot Framework for End-User Programming and Applications}, author={Coronado, Enrique and Mastrogiovanni, Fulvio and Venture, Gentiane}, booktitle={ROMANSY 22--Robot Design, Dynamics and Control}, pages={450--457}, year={2019}, publisher={Springer} }","title":"Installation"},{"location":"#what-is-nep","text":"Node Primitives (NEP) is a high-level library that provides simple and re-usable tools that enable the generation of software architectures for Human-Robot Interaction (HRI) and End-User Development (EUD). NEP is user-friendly : It was designed to be ease-to-install, ease-to-use and ease-to-learn. NEP is reusable : It enables the reuse of code and bridge between different middlewares. NEP is cross-platform : It can be used in Windows, Mac, Linux, Android and iOS. NEP is mainly a inter-process communication library using sockets. NEP is back-ended by ROS , ROS 2.0 and expand capabilities of ZeroMQ and nanomsg to enable ROS-like features and cross-platform software architectures for robotics. Deafult back-end implementation of NEP is ZeroMQ , which enable more user-friendly installation and provides better support for newer and older versions of most used desktop operating systems (Windows and MacOSX).","title":"What is NEP?"},{"location":"#1-pre-requirements","text":"For use Nao, Pepper and ROS-based robot it is required to have Python 2 installed. For Tensor Flow applications in Windows it is required to have Python 3 .\u3000 Tensorflow in OSX and Ubuntu can use either Python 2 or Python 3. Recomended way to install Python 2 on Windows and OSX See tutorial Recomended way to install Python 3 on Windows and OSX See tutorial","title":"1.- Pre-requirements"},{"location":"#2-install-nep-discovery-server","text":"Installer for windows Installer for OSX Installer for Ubuntu Source code (developers)","title":"2.- Install NEP Discovery Server"},{"location":"#3-minimal-installation-using-pip","text":"If you only have one version of Python (2 or 3) installed pip install nep pip install tornado For Python 2 also install: pip install trollius For Python 3 also install: pip install asyncio If you are in Windows and you have both Python 2 and Python 3 installed For Python 2: py -2 -m pip install -U nep py -2 -m pip install -U trollius py -2 -m pip install -U tornado For Python 3: py -3 -m pip install -U nep py -3 -m pip install -U asyncio py -3 -m pip install -U tornado If you are in OSX or Ubuntu and you have both Python 2 and Python 3 installed For Python 2: python2 -m pip install -U nep python2 -m pip install -U trollius python2 -m pip install -U tornado For Python 3: python3 -m pip install -U nep python3 -m pip install -U asyncio python3 -m pip install -U tornado","title":"3.- Minimal installation using pip"},{"location":"#4-advanced-installation-methods","text":"","title":"4.- Advanced installation methods"},{"location":"#41-aditional-back-end-options","text":"Defaul back-end solution of NEP is ZeroMQ which is installed by default, therefore not additional effort is needed to start to used it. The next table describes the installation complexity of other back-ends supported by NEP. Middleware Windows Linux Mac OS X Drawbacks nanomsg Very Very complex Very complex Binaries must be compiled ROS N.A Complex N.A Not fully support in Windows and Mac OS X ROS 2.0 Very complex Complex Complex Suported only in Windows 10 and few versions of Mac OS X NEP using ZeroMQ as back-end have been tested with success in Windows 7, 8, 8.1 and 10, Ubuntu 14, 16 and 18, as well as Mac OS X including the lastest version, Mojave (10.14).","title":"4.1 Aditional back-end options"},{"location":"#411-ros","text":"Follow the steps of ROS official documentation ROS installation details","title":"4.1.1 ROS"},{"location":"#412-ros-20","text":"Follow the steps of ROS 2.0 official documentation ROS 2.0 installation details","title":"4.1.2 ROS 2.0"},{"location":"#413-nanomsg","text":"Pre-compiled binaries for Windows - download here","title":"4.1.3 Nanomsg"},{"location":"#42-github","text":"","title":"4.2 Github"},{"location":"#421-old-version-01","text":"NEP Beta version (warning: older version with different API and less capabilities): Link to older version","title":"4.2.1 Old version (0.1)"},{"location":"#422-current-version-10","text":"Link to current version","title":"4.2.2 Current version (1.0)"},{"location":"#5-references","text":"Version 0.1 of NEP BibTeX: @incollection{coronado2019design, title={Design of a Human-Centered Robot Framework for End-User Programming and Applications}, author={Coronado, Enrique and Mastrogiovanni, Fulvio and Venture, Gentiane}, booktitle={ROMANSY 22--Robot Design, Dynamics and Control}, pages={450--457}, year={2019}, publisher={Springer} }","title":"5.- References"},{"location":"c_sharp/","text":"In construction ... NEP in CSharp (Visual Studio) {{ }} For the moment not all the patterns are suported {{ /note }} It is possible to communicate C# applications (using NetMQ) and python nodes written with NEP (using ZeroMQ). To install NetMQ in a C# project we need to open the Package Manager Console of Visual Studio (Tools/NuGet Package Manager/Package Manager Console) and write: Install-Package AsyncIO -Version 0.1.26 Install-Package NetMQ -Version 4.0.0.1 Install-Package Newtonsoft.Json {{ }} Tested only in NetMQ version 4.0.0.1, other versions can be non compatible with this tutorial {{ /warning }} Then we can add the NEP.cs clas to our C# project.","title":"C# version"},{"location":"c_sharp/#in-construction","text":"","title":"In construction ..."},{"location":"c_sharp/#nep-in-csharp-visual-studio","text":"{{ }} For the moment not all the patterns are suported {{ /note }} It is possible to communicate C# applications (using NetMQ) and python nodes written with NEP (using ZeroMQ). To install NetMQ in a C# project we need to open the Package Manager Console of Visual Studio (Tools/NuGet Package Manager/Package Manager Console) and write: Install-Package AsyncIO -Version 0.1.26 Install-Package NetMQ -Version 4.0.0.1 Install-Package Newtonsoft.Json {{ }} Tested only in NetMQ version 4.0.0.1, other versions can be non compatible with this tutorial {{ /warning }} Then we can add the NEP.cs clas to our C# project.","title":"NEP in CSharp (Visual Studio)"},{"location":"java/","text":"In construction ... NEP in Java A Java version of NEP will be avaliable soon (Aprox July 2018). NEP in MATLAB In order to use the ZeroMQ- and Java-based library of NEP in MATLAB it is needed to follow the next steps: 1.- Run the command prefdir in MATLAB. Navigate to that folder and check for a file named javaclasspath.txt . If the javaclasspath.txt file is not in the folder, then create it as a new txt file.. 2.- Open the file javaclasspath.txt in a text editor. 3.- It is needed to add the full path of the jar files jeromq-0.4.3.jar , gson-2.8.4.jar and nep_matlab- java version .jar that are inside NEP\\lib\\matlab . Where the value of java version can be 1.7 for Matlab 2017a and older, and 1.8 for Matlab 2017b and newer. For example if NEP is installed in Documents (in Windows) in Matlab 2018a the lines we need to add to the file javaclasspath.txt are: C:\\Users\\ user_name \\Documents\\NEP\\lib\\matlab\\jeromq-0.4.3.jar C:\\Users\\ user_name \\Documents\\NEP\\lib\\matlab\\gson-2.8.4.jar C:\\Users\\ user_name \\Documents\\NEP\\lib\\matlab\\nep_matlab-1.8.jar where user_name is the name of the user of your PC. 4.- Save and close the javaclasspath.txt folder 5.- Restart MATLAB Examples are inside the NEP\\samples\\matlab folder NEP in Swift A Swift version of NEP will be avaliable soon (Aprox September 2018).","title":"Java (Matlab and Android)"},{"location":"java/#in-construction","text":"","title":"In construction ..."},{"location":"java/#nep-in-java","text":"A Java version of NEP will be avaliable soon (Aprox July 2018).","title":"NEP in Java"},{"location":"java/#nep-in-matlab","text":"In order to use the ZeroMQ- and Java-based library of NEP in MATLAB it is needed to follow the next steps: 1.- Run the command prefdir in MATLAB. Navigate to that folder and check for a file named javaclasspath.txt . If the javaclasspath.txt file is not in the folder, then create it as a new txt file.. 2.- Open the file javaclasspath.txt in a text editor. 3.- It is needed to add the full path of the jar files jeromq-0.4.3.jar , gson-2.8.4.jar and nep_matlab- java version .jar that are inside NEP\\lib\\matlab . Where the value of java version can be 1.7 for Matlab 2017a and older, and 1.8 for Matlab 2017b and newer. For example if NEP is installed in Documents (in Windows) in Matlab 2018a the lines we need to add to the file javaclasspath.txt are: C:\\Users\\ user_name \\Documents\\NEP\\lib\\matlab\\jeromq-0.4.3.jar C:\\Users\\ user_name \\Documents\\NEP\\lib\\matlab\\gson-2.8.4.jar C:\\Users\\ user_name \\Documents\\NEP\\lib\\matlab\\nep_matlab-1.8.jar where user_name is the name of the user of your PC. 4.- Save and close the javaclasspath.txt folder 5.- Restart MATLAB Examples are inside the NEP\\samples\\matlab folder","title":"NEP in MATLAB"},{"location":"java/#nep-in-swift","text":"A Swift version of NEP will be avaliable soon (Aprox September 2018).","title":"NEP in Swift"},{"location":"patterns/","text":"Nodes and inter-process communication In order to reduce the effort required to generate more complex robotic systems, robot applications must be divided in a set of simple and interchangeable processes, also denoted as nodes . The ways in which different nodes communicates between them is denoted as inter-process communication . There exist different inter-process communication options. However the most extended approach on Robotics is sockets The idea of separate a robot application in simple nodes has the main objective to improve the reusability, maintainability and performance of robotic systems. This approach implies to start thinking in a \"divide and conquer\" way. Sockets and robot middlewares Sockets are commonly used when: (i) communication between nodes on the same machine is needed or (ii) communication between nodes on different machines or devices is needed. These nodes can be written on different programming language as long as share the same protocol and serialization approach. A socket is mainly defined by an endpoint which is composed by a protocol, a ip address and a port value. An example of endpoint definition is tcp://127.0.0.1:5000 , where tcp indicates the protocol, 127.0.0.1 indicates local ip adress and 5000 is the port of the connection. A typical solution adopted to create distributed robotic systems using sockets are messaging middlewares. NEP uses ZeroMQ, nanomsg, ROS and ROS 2.0 back-end messaging middleware libraries. The approach adopted in NEP is to keep the code independent of the middleware or trasport layer in order to enable an ease switch to future technologies. Comunication patterns Messaging patterns are generally used to describes the flow of communication between process in distributed systems. Two widely used messaging patterns in robotics are Request/Process/Reply and Publish/Subscribe . Request/Process/Reply In the Request/Process/Reply pattern, also denoted as client/server , a process sends a request for some data and then waits for the response to this request. However, if a response never comes a deadlock can occur (i.e a read operation cannot be performed when a write operation is in progress, and vice versa). This pattern is good for the cases where sincronization between two task is needed. Publish-Subscribe The publish/subscribe model is another classic pattern where the producers of messages, called publishers, send messages without the knowledge of what or if any receiver, called subscribers. Unlike typical client/server models, the communication in a publish/subscribe model is generally done in an asynchronous way. Most popular publish/subscribe schemes are based on the notion of topics . In this scheme subscribers can use a set of keywords called topics to filtered the information sent by publishers. Network architectures Network architectures used to creates distributed systems are characterised by a number of trade-offs that involves efficiency, determinism, scalability, security and robustness. NEP supports multiple network architectures which includes direct endpoint descriptions , Hybrid Peer to Peer (P2P) master server . A description of each approach is shown bellow. In a direct endpoint descriptions architecture the endpoints are manually set by the user. However, this approach must to be avoided when many process need to be connected between them or when it is expected to scale the number of nodes in the future. This is due that the manageability of the system gets worse when the number of nodes increases. When using a Hybrid P2P architecture all the nodes in the network are implicitly connected to some node denoted as master name server , which performs the management of endpoints in base of identifiers called topics . When the master node detects a topic registration request from some node, it assigns to the requested topic an endpoint direction (i.e., an IP address and a port). This endpoint information is saved and sent to the instances which have performed the registration request of the topic (e.g. a publisher or a subscriber). In this approach communication starts when at least one producer ( e.g. a publisher) and one receiver (e.g. a subscriber) have requested the registration of the same topic. This approach reduce manageability problems but is considered a single point of failure due that if the master name server accidentally crash or stops, new communication between nodes will be not possible. This approach is used in ROS.","title":"Basic theory"},{"location":"patterns/#nodes-and-inter-process-communication","text":"In order to reduce the effort required to generate more complex robotic systems, robot applications must be divided in a set of simple and interchangeable processes, also denoted as nodes . The ways in which different nodes communicates between them is denoted as inter-process communication . There exist different inter-process communication options. However the most extended approach on Robotics is sockets The idea of separate a robot application in simple nodes has the main objective to improve the reusability, maintainability and performance of robotic systems. This approach implies to start thinking in a \"divide and conquer\" way.","title":"Nodes and inter-process communication"},{"location":"patterns/#sockets-and-robot-middlewares","text":"Sockets are commonly used when: (i) communication between nodes on the same machine is needed or (ii) communication between nodes on different machines or devices is needed. These nodes can be written on different programming language as long as share the same protocol and serialization approach. A socket is mainly defined by an endpoint which is composed by a protocol, a ip address and a port value. An example of endpoint definition is tcp://127.0.0.1:5000 , where tcp indicates the protocol, 127.0.0.1 indicates local ip adress and 5000 is the port of the connection. A typical solution adopted to create distributed robotic systems using sockets are messaging middlewares. NEP uses ZeroMQ, nanomsg, ROS and ROS 2.0 back-end messaging middleware libraries. The approach adopted in NEP is to keep the code independent of the middleware or trasport layer in order to enable an ease switch to future technologies.","title":"Sockets and robot middlewares"},{"location":"patterns/#comunication-patterns","text":"Messaging patterns are generally used to describes the flow of communication between process in distributed systems. Two widely used messaging patterns in robotics are Request/Process/Reply and Publish/Subscribe .","title":"Comunication patterns"},{"location":"patterns/#requestprocessreply","text":"In the Request/Process/Reply pattern, also denoted as client/server , a process sends a request for some data and then waits for the response to this request. However, if a response never comes a deadlock can occur (i.e a read operation cannot be performed when a write operation is in progress, and vice versa). This pattern is good for the cases where sincronization between two task is needed.","title":"Request/Process/Reply"},{"location":"patterns/#publish-subscribe","text":"The publish/subscribe model is another classic pattern where the producers of messages, called publishers, send messages without the knowledge of what or if any receiver, called subscribers. Unlike typical client/server models, the communication in a publish/subscribe model is generally done in an asynchronous way. Most popular publish/subscribe schemes are based on the notion of topics . In this scheme subscribers can use a set of keywords called topics to filtered the information sent by publishers.","title":"Publish-Subscribe"},{"location":"patterns/#network-architectures","text":"Network architectures used to creates distributed systems are characterised by a number of trade-offs that involves efficiency, determinism, scalability, security and robustness. NEP supports multiple network architectures which includes direct endpoint descriptions , Hybrid Peer to Peer (P2P) master server . A description of each approach is shown bellow. In a direct endpoint descriptions architecture the endpoints are manually set by the user. However, this approach must to be avoided when many process need to be connected between them or when it is expected to scale the number of nodes in the future. This is due that the manageability of the system gets worse when the number of nodes increases. When using a Hybrid P2P architecture all the nodes in the network are implicitly connected to some node denoted as master name server , which performs the management of endpoints in base of identifiers called topics . When the master node detects a topic registration request from some node, it assigns to the requested topic an endpoint direction (i.e., an IP address and a port). This endpoint information is saved and sent to the instances which have performed the registration request of the topic (e.g. a publisher or a subscriber). In this approach communication starts when at least one producer ( e.g. a publisher) and one receiver (e.g. a subscriber) have requested the registration of the same topic. This approach reduce manageability problems but is considered a single point of failure due that if the master name server accidentally crash or stops, new communication between nodes will be not possible. This approach is used in ROS.","title":"Network architectures"},{"location":"publish/","text":"In a Publish-Subscribe pattern, a producer of messages (publisher) send messages without knowing if any receiver (subscriber) exists. Two option are ecpresed this tutorial: Option 1: using fixed IP and port values (for very simple architectures) Option 2: Using a ROS, ROS2.0, ZMQ and nanomsg reusable architectures Options 1 can be enough when the problem to solve requires only to connect two process that run, for example, in diferent machines or in diferent version of Python (2 and 3). However, if it is need to have more lost-lasting, and reusable code, the option 2 is better suited. 1.- Using fixed IP and port values A simple publisher node can be defined as: import nep import time # Create a new node node = nep.node( publisher_sample ) # Select the configuration of the publisher conf = node.direct(ip = 127.0.0.1 , port = 9090, mode = one2many ) # Set the topic and the configuration of the publisher pub = node.new_pub( pub_sub_test , json ,conf) # Publish a message each second while True: msg = { info : hello } pub.publish(msg) time.sleep(1) First we need to create a new nep.node instance with is denoted as node . The we define the type of architecture to use in the line: conf = node.direct(ip = \"127.0.0.1\", port = 9090, mode =\"one2many\") This line define the IP address and port of the publisher to create, as well the type of publisher, which can be \"one2many\" or many2one . On the one hand, in the \"one2many\" mode only one publisher can send messages an undefined number of subscribers. On the other hand, in the \"many2one\" mode an undefined number of publisher can send information to just one subscriber. WARNING 1: Nodes with diferent mode (one2many or many2one) can not be communicated betweem them. WARNING 2: It is not possible to execute more than one \"one2many\" publishers that have the same IP and port values. WARNING 3: It is not possible to execute more than one \"many2one\" susbcribers that have the same IP and port values. Then we need to define a new publisher instance using the new_pub function. In this function we need to define a topic name (message identifier), the type of message (\"json\" or \"string\") and the configuration of the publisher. In this case the topic is defined with the name of pub_sub_test and the message type is json (which enable to use python dictionaries). We also select the configuration value defined in conf variable. The created publisher is then defined in the pub instance. Finally a message defined as a python dictionary is sent each second using the publish function of the pub instance. The subcriber node able to read the messages of the publisher defined before can be defined as: import nep # Function executed each time gets a new message def mycallback(msg): print (msg) # Print message # Use here msg for some operation ... # Create a new node node = nep.node( subscriber_sample ) # Select the configuration of the subscriber conf = node.direct(ip = 127.0.0.1 , port = 9090, mode = one2many ) # Define a new subcriber using a callback function sub = node.new_callback( pub_sub_test , json , mycallback, conf) node.spin() In this example we use a function denoted as mycallback , which is executed in a diffenert thread and that be executed each time a new message is read by the subscriber. The configuration set to the subscriber must be the same that the publisher. In this case we use the function new_callback to create the subcriber instance. This function requires the same topic name defined in the subscriber ( \"pub_sub_test\" ), the type of message to receive ( \"json\" ), the function that will be executed each time a message arrives ( mycallback ), and the subscriber configuration defined in conf . Communication between different PCs Different computers using different operating systems can be connected using a direct network configuration. This devices need to be connected the same network and specify the IP address of one of the PCs in the network and the same port. The IP value will depend of the publish-subscribe configuration mode. .tg {border-collapse:collapse;border-spacing:0;} .tg td{font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:1px;overflow:hidden;word-break:normal;border-color:black;} .tg th{font-family:Arial, sans-serif;font-size:14px;font-weight:normal;padding:10px 5px;border-style:solid;border-width:1px;overflow:hidden;word-break:normal;border-color:black;} .tg .tg-h8bj{font-weight:bold;background-color:#c0c0c0;color:#333333;border-color:inherit;text-align:center;vertical-align:top} .tg .tg-us36{border-color:inherit;vertical-align:top} .tg .tg-00jj{font-style:italic;border-color:inherit;vertical-align:top} Mode Set the IP value of one2many Publisher node many2one Subscriber node For example if a one2many publisher node in a PC with IP 192.168.11.1 need to communicate with a Subscriber node in other PC with IP 192.168.11.2 , the configuration of the publisher in port 10090 must be: conf = node.direct(ip = 192.168.11.1 , port = 10090, mode = one2many ) and subscriber configuration must be as follow: conf = node.direct(ip = 192.168.11.1 , port = 10090, mode = one2many ) 2.- ROS, ROS2, ZMQ and nanomsg reusable architectures","title":"Publish-Subscribe"},{"location":"publish/#1-using-fixed-ip-and-port-values","text":"A simple publisher node can be defined as: import nep import time # Create a new node node = nep.node( publisher_sample ) # Select the configuration of the publisher conf = node.direct(ip = 127.0.0.1 , port = 9090, mode = one2many ) # Set the topic and the configuration of the publisher pub = node.new_pub( pub_sub_test , json ,conf) # Publish a message each second while True: msg = { info : hello } pub.publish(msg) time.sleep(1) First we need to create a new nep.node instance with is denoted as node . The we define the type of architecture to use in the line: conf = node.direct(ip = \"127.0.0.1\", port = 9090, mode =\"one2many\") This line define the IP address and port of the publisher to create, as well the type of publisher, which can be \"one2many\" or many2one . On the one hand, in the \"one2many\" mode only one publisher can send messages an undefined number of subscribers. On the other hand, in the \"many2one\" mode an undefined number of publisher can send information to just one subscriber. WARNING 1: Nodes with diferent mode (one2many or many2one) can not be communicated betweem them. WARNING 2: It is not possible to execute more than one \"one2many\" publishers that have the same IP and port values. WARNING 3: It is not possible to execute more than one \"many2one\" susbcribers that have the same IP and port values. Then we need to define a new publisher instance using the new_pub function. In this function we need to define a topic name (message identifier), the type of message (\"json\" or \"string\") and the configuration of the publisher. In this case the topic is defined with the name of pub_sub_test and the message type is json (which enable to use python dictionaries). We also select the configuration value defined in conf variable. The created publisher is then defined in the pub instance. Finally a message defined as a python dictionary is sent each second using the publish function of the pub instance. The subcriber node able to read the messages of the publisher defined before can be defined as: import nep # Function executed each time gets a new message def mycallback(msg): print (msg) # Print message # Use here msg for some operation ... # Create a new node node = nep.node( subscriber_sample ) # Select the configuration of the subscriber conf = node.direct(ip = 127.0.0.1 , port = 9090, mode = one2many ) # Define a new subcriber using a callback function sub = node.new_callback( pub_sub_test , json , mycallback, conf) node.spin() In this example we use a function denoted as mycallback , which is executed in a diffenert thread and that be executed each time a new message is read by the subscriber. The configuration set to the subscriber must be the same that the publisher. In this case we use the function new_callback to create the subcriber instance. This function requires the same topic name defined in the subscriber ( \"pub_sub_test\" ), the type of message to receive ( \"json\" ), the function that will be executed each time a message arrives ( mycallback ), and the subscriber configuration defined in conf .","title":"1.- Using fixed IP and port values"},{"location":"publish/#communication-between-different-pcs","text":"Different computers using different operating systems can be connected using a direct network configuration. This devices need to be connected the same network and specify the IP address of one of the PCs in the network and the same port. The IP value will depend of the publish-subscribe configuration mode. .tg {border-collapse:collapse;border-spacing:0;} .tg td{font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:1px;overflow:hidden;word-break:normal;border-color:black;} .tg th{font-family:Arial, sans-serif;font-size:14px;font-weight:normal;padding:10px 5px;border-style:solid;border-width:1px;overflow:hidden;word-break:normal;border-color:black;} .tg .tg-h8bj{font-weight:bold;background-color:#c0c0c0;color:#333333;border-color:inherit;text-align:center;vertical-align:top} .tg .tg-us36{border-color:inherit;vertical-align:top} .tg .tg-00jj{font-style:italic;border-color:inherit;vertical-align:top} Mode Set the IP value of one2many Publisher node many2one Subscriber node For example if a one2many publisher node in a PC with IP 192.168.11.1 need to communicate with a Subscriber node in other PC with IP 192.168.11.2 , the configuration of the publisher in port 10090 must be: conf = node.direct(ip = 192.168.11.1 , port = 10090, mode = one2many ) and subscriber configuration must be as follow: conf = node.direct(ip = 192.168.11.1 , port = 10090, mode = one2many )","title":"Communication between different PCs"},{"location":"publish/#2-ros-ros2-zmq-and-nanomsg-reusable-architectures","text":"","title":"2.- ROS, ROS2, ZMQ and nanomsg reusable architectures"},{"location":"python2/","text":"In order to support most of the robotic software currently avalaible the installation of Python 2 in 32 bits version is the best option. Windows 1.- Go to the official Python 2 download page . 2.- Download Windows x86 MSI installer 3.- Execute the downloaded installer. 4.- Very important : when reaching next interface be sure of activate Add python.exe to Path- Will be installed on local hard drive 5.- Continue and finish the installation MacOS Go to the official Python 2 download page . Download macOS 64-bit installer, execute this installer and follow the wizard using the default options.","title":"Python 2 recommended installation way"},{"location":"python2/#windows","text":"1.- Go to the official Python 2 download page . 2.- Download Windows x86 MSI installer 3.- Execute the downloaded installer. 4.- Very important : when reaching next interface be sure of activate Add python.exe to Path- Will be installed on local hard drive 5.- Continue and finish the installation","title":"Windows"},{"location":"python2/#macos","text":"Go to the official Python 2 download page . Download macOS 64-bit installer, execute this installer and follow the wizard using the default options.","title":"MacOS"},{"location":"python3/","text":"Windows 1.- Go to the official Python 3 download page . 2.- Download the lastest Python 3 version 3.- Execute the downloaded installer. 4.- Very important : when reaching next interface be sure of activate * Add python 3.7 to PATH 5.- Continue and finish the installation Windows using ROS 2.0 Follow ROS 2.0 instructions avaliables here . MacOS (for use Cozmo and Vector robots or ROS 2.0) Install HomeBrew as indicated in Homebrew official page . Open a macOS Terminal prompt and write: brew update brew install python3","title":"Python 3 recommended installation way"},{"location":"python3/#windows","text":"1.- Go to the official Python 3 download page . 2.- Download the lastest Python 3 version 3.- Execute the downloaded installer. 4.- Very important : when reaching next interface be sure of activate * Add python 3.7 to PATH 5.- Continue and finish the installation","title":"Windows"},{"location":"python3/#windows-using-ros-20","text":"Follow ROS 2.0 instructions avaliables here .","title":"Windows using ROS 2.0"},{"location":"python3/#macos-for-use-cozmo-and-vector-robots-or-ros-20","text":"Install HomeBrew as indicated in Homebrew official page . Open a macOS Terminal prompt and write: brew update brew install python3","title":"MacOS (for use Cozmo and Vector robots or ROS 2.0)"},{"location":"server/","text":"In the Client-Server pattern a node (client) sends a request of some data to other node (server). The execution of the client node blocks its execution until a response is send by the server. Examples of client-server applications are shown bellow. Using fixed IP and port When simple applications with few nodes are needed a fixed endpoint value (IP and port) can be enough Simple client A simple client node asking each 2 seconds for some information can be defined as: import nep import time client = nep.client('127.0.0.1', 8014) # Create a new client instance while True: msg = { message : client request } # Message to send as request client.send_info(msg) # Send request print (client.listen_info()) # Wait for server response time.sleep(2) # Wait one second In this example a new instance of the nep.client class is created with the line: client = nep.client('127.0.0.1', 8014) For this, the IP and PORT parameters are defined as '127.0.0.1' and 8014 respectivelly. The function send_info can be used to send a request to the server. This request must be defined as a python dictionary. In this case the dictionary {\"message\":\"client request\"} is defined to be send as request. The function listen_info waits until the server send its response. This function also reads the message sent by the server. Simple server The next Python script shown a simple example of a server node. import nep # Import nep library server = nep.server('127.0.0.1', 8014) #Create a new server instance while True: request = server.listen_info() # Wait for client request server.send_info({ message : hello client }) # Send server response print (request) In this example a new instance of the server.nep class is created with the line: server = nep.server('127.0.0.1', 8014) We need to define the same IP and PORT values that in the client node. The functions listen_info and send_info can be used to read a client request and send a response respectively. In this example the response to be sent in defined as {\"message\":\"hello client\"} . Using default Python sockets The client ans server classes of NEP uses ZeroMQ by deafult (sockets with steroids). However, an optional parameter can be used to select the soxket type. In order to use TCP/IP POSIX sockets a client with port value of 30000 can be defined as: client = nep.client('127.0.0.1', 30000, 'normal') However, instead of dictionaries messages must be send as string, a full example is shown bellow: import nep import time client = nep.client('127.0.0.1', 30000, 'normal') # Create a new client instance while True: msg = hello server # Message to send as request client.send_info(msg) # Send request print (client.listen_info()) # Wait for server response time.sleep(1) # Wait one second The server node used to response the client requests can be defined as: import nep # Import nep library server = nep.server('127.0.0.1', 30000, 'normal') #Create a new server instance while True: request = server.listen_info() # Wait for client request print (request) server.send_info( server response ) # Send server response In this case it is also needed to define the socket types as normal as shown bellow: server = nep.server('127.0.0.1', 30000, 'normal') WARNING: It is not possible to communicate a ZeroMQ socket and a normal TCP/IP POSIX socket Using NEP master When the number of nodes increases the management of IP and port values becomes a tedious task. In order avoid this problem NEP nodes using the client/server pattern can be managed by the NEP master. An example of a client connected through NEP master is shown bellow: import nep import time node = nep.node( client_test ) # New nep node client = node.new_client( client_server_sample ) # Topic while True: msg = { message : client request } # Message to send as request client.send_info(msg) # Send request print (client.listen_info()) # Wait for server response time.sleep(1) # Wait one second However, the way to define the client present some diferences. First, it is need to create a nep.node instance and define a unique name for this node, in this case that name is defined as \"client_test\" . Then, it is required to start a new client instance using the new_client() function. It is also requires to define a name for the client. This name, denoted as topic, will be used by the NEP master to assign some suitable IP and port values to the client instance. In this case the topic is defined as \"client_server_sample\" . The server is defined in a similar way but using the new_server() function as shown in the next example: import nep # Import nep library node = nep.node( server_test ) # New nep node server = node.new_server( client_server_sample ) # Topic while True: msg = { message : hello } # Message to send as response request = server.listen_info() # Wait for client request server.send_info(msg) # Send server response print (request) WARNING: NEP master must be first started in order to use these last two examples","title":"Client-Server"},{"location":"server/#using-fixed-ip-and-port","text":"When simple applications with few nodes are needed a fixed endpoint value (IP and port) can be enough","title":"Using fixed IP and port"},{"location":"server/#simple-client","text":"A simple client node asking each 2 seconds for some information can be defined as: import nep import time client = nep.client('127.0.0.1', 8014) # Create a new client instance while True: msg = { message : client request } # Message to send as request client.send_info(msg) # Send request print (client.listen_info()) # Wait for server response time.sleep(2) # Wait one second In this example a new instance of the nep.client class is created with the line: client = nep.client('127.0.0.1', 8014) For this, the IP and PORT parameters are defined as '127.0.0.1' and 8014 respectivelly. The function send_info can be used to send a request to the server. This request must be defined as a python dictionary. In this case the dictionary {\"message\":\"client request\"} is defined to be send as request. The function listen_info waits until the server send its response. This function also reads the message sent by the server.","title":"Simple client"},{"location":"server/#simple-server","text":"The next Python script shown a simple example of a server node. import nep # Import nep library server = nep.server('127.0.0.1', 8014) #Create a new server instance while True: request = server.listen_info() # Wait for client request server.send_info({ message : hello client }) # Send server response print (request) In this example a new instance of the server.nep class is created with the line: server = nep.server('127.0.0.1', 8014) We need to define the same IP and PORT values that in the client node. The functions listen_info and send_info can be used to read a client request and send a response respectively. In this example the response to be sent in defined as {\"message\":\"hello client\"} .","title":"Simple server"},{"location":"server/#using-default-python-sockets","text":"The client ans server classes of NEP uses ZeroMQ by deafult (sockets with steroids). However, an optional parameter can be used to select the soxket type. In order to use TCP/IP POSIX sockets a client with port value of 30000 can be defined as: client = nep.client('127.0.0.1', 30000, 'normal') However, instead of dictionaries messages must be send as string, a full example is shown bellow: import nep import time client = nep.client('127.0.0.1', 30000, 'normal') # Create a new client instance while True: msg = hello server # Message to send as request client.send_info(msg) # Send request print (client.listen_info()) # Wait for server response time.sleep(1) # Wait one second The server node used to response the client requests can be defined as: import nep # Import nep library server = nep.server('127.0.0.1', 30000, 'normal') #Create a new server instance while True: request = server.listen_info() # Wait for client request print (request) server.send_info( server response ) # Send server response In this case it is also needed to define the socket types as normal as shown bellow: server = nep.server('127.0.0.1', 30000, 'normal') WARNING: It is not possible to communicate a ZeroMQ socket and a normal TCP/IP POSIX socket","title":"Using default Python sockets"},{"location":"server/#using-nep-master","text":"When the number of nodes increases the management of IP and port values becomes a tedious task. In order avoid this problem NEP nodes using the client/server pattern can be managed by the NEP master. An example of a client connected through NEP master is shown bellow: import nep import time node = nep.node( client_test ) # New nep node client = node.new_client( client_server_sample ) # Topic while True: msg = { message : client request } # Message to send as request client.send_info(msg) # Send request print (client.listen_info()) # Wait for server response time.sleep(1) # Wait one second However, the way to define the client present some diferences. First, it is need to create a nep.node instance and define a unique name for this node, in this case that name is defined as \"client_test\" . Then, it is required to start a new client instance using the new_client() function. It is also requires to define a name for the client. This name, denoted as topic, will be used by the NEP master to assign some suitable IP and port values to the client instance. In this case the topic is defined as \"client_server_sample\" . The server is defined in a similar way but using the new_server() function as shown in the next example: import nep # Import nep library node = nep.node( server_test ) # New nep node server = node.new_server( client_server_sample ) # Topic while True: msg = { message : hello } # Message to send as response request = server.listen_info() # Wait for client request server.send_info(msg) # Send server response print (request) WARNING: NEP master must be first started in order to use these last two examples","title":"Using NEP master"}]}