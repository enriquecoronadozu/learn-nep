{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"What is NEP? Node Primitives (NEP) is a user-friendly , reusable and cross-platform framework for building software architectures able to support Human-Robot Interaction (HRI) and robot End-User Development (EUD). NEP is user-friendly : It was designed to be easy-to-install, easy-to-use and ease-to-learn. NEP is reusable : NEP modules can easily be on different robot middlewares and programming languages NEP is cross-platform : It has full support for Windows, Mac, Linux. NEP is mainly an inter-process communication library using sockets. NEP is back-ended by ROS , ROS 2.0 , ZeroMQ and nanomsg . However, default back-end implementation of NEP is ZeroMQ , which enable more user-friendly installation and provides better support for newer and older versions of most used desktop operating systems (Windows and MacOSX) How to install NEP? 1 - Install Python (compulsory) 2 - Install NEP library for Python (compulsory) 3 - Install NEP Discovery Server (recommended) Citation Older version of NEP is described in: @incollection{coronado2019design, title={Design of a Human-Centered Robot Framework for End-User Programming and Applications}, author={Coronado, Enrique and Mastrogiovanni, Fulvio and Venture, Gentiane}, booktitle={ROMANSY 22--Robot Design, Dynamics and Control}, pages={450--457}, year={2019}, publisher={Springer} }","title":"Introduction"},{"location":"#what-is-nep","text":"Node Primitives (NEP) is a user-friendly , reusable and cross-platform framework for building software architectures able to support Human-Robot Interaction (HRI) and robot End-User Development (EUD). NEP is user-friendly : It was designed to be easy-to-install, easy-to-use and ease-to-learn. NEP is reusable : NEP modules can easily be on different robot middlewares and programming languages NEP is cross-platform : It has full support for Windows, Mac, Linux. NEP is mainly an inter-process communication library using sockets. NEP is back-ended by ROS , ROS 2.0 , ZeroMQ and nanomsg . However, default back-end implementation of NEP is ZeroMQ , which enable more user-friendly installation and provides better support for newer and older versions of most used desktop operating systems (Windows and MacOSX)","title":"What is NEP?"},{"location":"#how-to-install-nep","text":"1 - Install Python (compulsory) 2 - Install NEP library for Python (compulsory) 3 - Install NEP Discovery Server (recommended)","title":"How to install NEP?"},{"location":"#citation","text":"Older version of NEP is described in: @incollection{coronado2019design, title={Design of a Human-Centered Robot Framework for End-User Programming and Applications}, author={Coronado, Enrique and Mastrogiovanni, Fulvio and Venture, Gentiane}, booktitle={ROMANSY 22--Robot Design, Dynamics and Control}, pages={450--457}, year={2019}, publisher={Springer} }","title":"Citation"},{"location":"advanced/","text":"1.- Back-end options The default back-end solution of NEP is ZeroMQ which is installed by default. Therefore no additional effort is needed to start to use it. The next table describes the installation complexity of other back-ends supported by NEP. Middleware Windows Linux Mac OS X Drawbacks nanomsg Easy Very complex Very complex Binaries must be compiled in many cases ROS N.A Complex N.A ROS do not fully supports Windows and Mac OS X ROS 2.0 Very complex Complex Complex ROS 2.0 only supports Windows 10, few version of Ubuntu and MacOS X (10.14 Mojave still not supported) NEP using ZeroMQ as back-end has been tested with success in Windows 7, 8, 8.1 and 10, Ubuntu 16.04, 16.10, 18.04 and 18.10, as well as Mac OS X latest versions, including Mojave (10.14). 2.- Using ROS Follow steps for intall ROS from official documentation ROS installation details 3.- Using ROS 2.0 Follow steps for intall ROS 2.0 from official documentation ROS 2.0 installation details 4.- Using Nanomsg Pre-compiled binaries for Windows - download here 5.- Github 5.1 Old version (0.1) NEP Beta version (warning: older version with different API and less capabilities): Link to older version @incollection{coronado2019design, title={Design of a Human-Centered Robot Framework for End-User Programming and Applications}, author={Coronado, Enrique and Mastrogiovanni, Fulvio and Venture, Gentiane}, booktitle={ROMANSY 22--Robot Design, Dynamics and Control}, pages={450--457}, year={2019}, publisher={Springer} } 5.2 Current version (1.0) Link to current version","title":"Advanced installation"},{"location":"advanced/#1-back-end-options","text":"The default back-end solution of NEP is ZeroMQ which is installed by default. Therefore no additional effort is needed to start to use it. The next table describes the installation complexity of other back-ends supported by NEP. Middleware Windows Linux Mac OS X Drawbacks nanomsg Easy Very complex Very complex Binaries must be compiled in many cases ROS N.A Complex N.A ROS do not fully supports Windows and Mac OS X ROS 2.0 Very complex Complex Complex ROS 2.0 only supports Windows 10, few version of Ubuntu and MacOS X (10.14 Mojave still not supported) NEP using ZeroMQ as back-end has been tested with success in Windows 7, 8, 8.1 and 10, Ubuntu 16.04, 16.10, 18.04 and 18.10, as well as Mac OS X latest versions, including Mojave (10.14).","title":"1.- Back-end options"},{"location":"advanced/#2-using-ros","text":"Follow steps for intall ROS from official documentation ROS installation details","title":"2.- Using ROS"},{"location":"advanced/#3-using-ros-20","text":"Follow steps for intall ROS 2.0 from official documentation ROS 2.0 installation details","title":"3.- Using ROS 2.0"},{"location":"advanced/#4-using-nanomsg","text":"Pre-compiled binaries for Windows - download here","title":"4.- Using Nanomsg"},{"location":"advanced/#5-github","text":"","title":"5.- Github"},{"location":"advanced/#51-old-version-01","text":"NEP Beta version (warning: older version with different API and less capabilities): Link to older version @incollection{coronado2019design, title={Design of a Human-Centered Robot Framework for End-User Programming and Applications}, author={Coronado, Enrique and Mastrogiovanni, Fulvio and Venture, Gentiane}, booktitle={ROMANSY 22--Robot Design, Dynamics and Control}, pages={450--457}, year={2019}, publisher={Springer} }","title":"5.1 Old version (0.1)"},{"location":"advanced/#52-current-version-10","text":"Link to current version","title":"5.2 Current version (1.0)"},{"location":"c_sharp/","text":"In construction ... NEP in CSharp (Visual Studio) {{ }} For the moment not all the patterns are suported {{< /note>}} It is possible to communicate C# applications (using NetMQ) and python nodes written with NEP (using ZeroMQ). To install NetMQ in a C# project we need to open the Package Manager Console of Visual Studio (Tools/NuGet Package Manager/Package Manager Console) and write: Install-Package AsyncIO -Version 0.1.26 Install-Package NetMQ -Version 4.0.0.1 Install-Package Newtonsoft.Json {{ }} Tested only in NetMQ version 4.0.0.1, other versions can be non compatible with this tutorial {{< /warning>}} Then we can add the NEP.cs clas to our C# project.","title":"C#"},{"location":"c_sharp/#in-construction","text":"","title":"In construction ..."},{"location":"c_sharp/#nep-in-csharp-visual-studio","text":"{{ }} For the moment not all the patterns are suported {{< /note>}} It is possible to communicate C# applications (using NetMQ) and python nodes written with NEP (using ZeroMQ). To install NetMQ in a C# project we need to open the Package Manager Console of Visual Studio (Tools/NuGet Package Manager/Package Manager Console) and write: Install-Package AsyncIO -Version 0.1.26 Install-Package NetMQ -Version 4.0.0.1 Install-Package Newtonsoft.Json {{ }} Tested only in NetMQ version 4.0.0.1, other versions can be non compatible with this tutorial {{< /warning>}} Then we can add the NEP.cs clas to our C# project.","title":"NEP in CSharp (Visual Studio)"},{"location":"matlab/","text":"NEP in MATLAB: Installation NOTE: It is required matlab 2018b or above In order to use the NEP in MATLAB using ZeroMQ back-end it is needed to follow the next steps: 1.- Download lastest release version of NEP-matlab.zip from: Link to NEP releases 2.- Unzip this file which contain jeromq-0.4.3.jar , gson-2.8.4.jar and nep.jar java binaries. 3.- We need to save these files in some locations where matlab can always find it. In windows we recommend to create a new folder in C:\\nep-matlab and put inside that folder these files. 4.- Run the command prefdir in MATLAB. Navigate to that folder and check for a file named javaclasspath.txt . If the javaclasspath.txt file is not in the folder, then create it as a new text file. 5.- Open the file javaclasspath.txt in a text editor. 6.- It is needed to write the full path of the jar files jeromq-0.4.3.jar , gson-2.8.4.jar and nep.jar described this file. For example following the recommendation of step 3, the lines we need to add to the file javaclasspath.txt are: C:\\nep-matlab\\jeromq-0.4.3.jar C:\\nep-matlab\\gson-2.8.4.jar C:\\nep-matlab\\nep.jar 7.- Save and close the javaclasspath.txt folder 8.- Restart MATLAB 9.- See examples to quick start","title":"Installation"},{"location":"matlab/#nep-in-matlab-installation","text":"NOTE: It is required matlab 2018b or above In order to use the NEP in MATLAB using ZeroMQ back-end it is needed to follow the next steps: 1.- Download lastest release version of NEP-matlab.zip from: Link to NEP releases 2.- Unzip this file which contain jeromq-0.4.3.jar , gson-2.8.4.jar and nep.jar java binaries. 3.- We need to save these files in some locations where matlab can always find it. In windows we recommend to create a new folder in C:\\nep-matlab and put inside that folder these files. 4.- Run the command prefdir in MATLAB. Navigate to that folder and check for a file named javaclasspath.txt . If the javaclasspath.txt file is not in the folder, then create it as a new text file. 5.- Open the file javaclasspath.txt in a text editor. 6.- It is needed to write the full path of the jar files jeromq-0.4.3.jar , gson-2.8.4.jar and nep.jar described this file. For example following the recommendation of step 3, the lines we need to add to the file javaclasspath.txt are: C:\\nep-matlab\\jeromq-0.4.3.jar C:\\nep-matlab\\gson-2.8.4.jar C:\\nep-matlab\\nep.jar 7.- Save and close the javaclasspath.txt folder 8.- Restart MATLAB 9.- See examples to quick start","title":"NEP in MATLAB: Installation"},{"location":"matlab_examples/","text":"NEP in MATLAB: Examples NOTE: It is required matlab 2018b or above MATLAB as Subscriber 1.- From Python to MATLAB in the same computer This example shows how a Subscriber node in MATLAB can read messages from a Publisher in Python. Both nodes are executed in the same computer It is required to execute the NEP Discovery Server before running the scripts of this example Being a Python publisher node publisher_sample connecting to the matlab topic and sending JSON messages as following: import nep import time import sys node = nep.node(\"publisher_sample\") pub = node.new_pub(\"matlab\",\"json\") while True: msg = data = {\"message\":\"hello\", \"value\":1.0} print (\"sending: \" + str(msg)) pub.publish(msg) time.sleep(1) The required subscriber in matlab can be defined as follow: import nep.node; node = nep.node(\"subscriber_sample\"); sub = node.new_sub(\"matlab\"); In order to read a message from a publisher we use the function msg = sub.listen(); However, this function is non-blocking, therefore if data is not available in the socket, then it will return \"{}\". Therefore, we need to add a conditional strcmp(msg,\"{}\") to ignore it when not messages are read. Then, we can also put the listen() function inside a loop as follow: while 1 msg = sub.listen(); if strcmp(msg,\"{}\") pause(.00001) else value = jsondecode(string(msg)) end end In this case when data is not read the program will wait .00001 seconds; otherwise, the value read will be shown as a MATLAB structure. Due that values returned by listen() are in Java string format, we need to use the functions string() and jsondecode() to transform from Java strings to MATLAB strings, and from MATLAB string to MATLAB structures respectively. The full MATLAB script is defined as: import nep.node; node = nep.node(\"subscriber_sample\"); sub = node.new_sub(\"matlab\"); while 1 msg = sub.listen(); if strcmp(msg,\"{}\") pause(.00001) else value = jsondecode(string(msg)) end end 2.- From Python to MATLAB in different computer In order to communicate a Python publisher with a MATLAB subscriber running in different PC, we need to do some small changes to the code shown in example 1. Now the python script running the publisher can be defined as: import nep import time conf = node.direct(ip = \"192.168.0.100\", port = 9090, mode =\"one2many\") pub = node.new_pub(\"matlab\", \"json\", conf) while True: msg = data = {\"message\":\"hello\", \"value\":1.0} print (\"sending: \" + str(msg)) pub.publish(msg) time.sleep(1) Note that we change the next lines with respect publisher example 1: conf = node.direct(ip = \"192.168.0.100\", port = 9090, mode =\"one2many\") pub = node.new_pub(\"matlab\", \"json\", conf) which indicate that need to send messages from PC with IP address of 192.168.0.100 (change this value for the IP address of PC with Python) and port 9090 (This value must be the same in Python and MATLAB). More details in python pub-sub The MATLAB publisher able to communicate to this python script can be defined as: import nep.node; node = nep.node(\"subscriber_sample\"); sub = node.new_sub(\"matlab\", \"192.168.0.100\", 9090,\"one2many\"); while 1 msg = sub.listen(); if strcmp(msg,\"{}\") pause(.00001) else value = jsondecode(string(msg)) end end Check example 1 for more details. MATLAB as a publisher 3.- From MATLAB to Python in the same computer This example shows how a Publisher node in MATLAB can communicate with a Subscriber in Python. Both nodes are executed in the same computer It is required to execute the NEP Discovery Server before running the script of this example Being a Python subscriber node subscriber_sample connecting to the matlab topic and reading JSON messages as following: import nep node = nep.node(\"subscriber_sample\") sub = node.new_sub(\"matlab\", \"json\") while True: s, msg = sub.listen() if s: # Info avaliable only if s == True print(str(msg)) The required publisher in matlab can be defined as follow: import nep.node; node = nep.node(\"publisher_sample\"); pub = node.new_pub(\"matlab\"); We need to define a message to send as a JSON value, for this we need to define a MATLAB structure. For example if we need to send the next JSON information: {\"message\":\"hello\", \"value\": 0} This can be defined in MATLAB with the next lines: msg = struct('message','hello','value',0) json_msg = jsonencode(msg) Where variable json_msg will contain the JSON message to send. In order to send the JSON messages to the subscriber, we can use the next line: pub.publish(json_msg) The full example of Publisher in MATLAB is shown bellow: import nep.node; node = nep.node(\"publisher_sample\"); pub = node.new_pub(\"matlab\"); msg = struct('message','hello','value',0); json_msg = jsonencode(msg); while 1 pub.publish(json_msg) pause(1) end 4.- From MATLAB to Python in different computer In order to communicate a MATLAB publisher with a Python subscriber running in different PC, we need to do some small changes to the code shown in example 3. Now the python script running the subscriber can be defined as: import nep node = nep.node(\"subscriber_sample\") conf = node.direct(ip = \"127.0.0.1\", port = 9090, mode =\"one2many\") sub = node.new_sub(\"matlab\", \"json\", conf) while True: s, msg = sub.listen() if s: # Info avaliable only if s == True print(str(msg)) Note that we change the next lines with respect subscriber in example 3: conf = node.direct(ip = \"192.168.0.101\", port = 9090, mode =\"one2many\") sub = node.new_sub(\"matlab\", \"json\", conf) which indicate that need to read messages from PC with IP address of 192.168.0.100 (change this value for the IP address of PC with MATLAB) and port 9090 (This value must be the same in Python and MATLAB). More details in python pub-sub The MATLAB publisher able to communicate to this python script can be defined as: import nep.node; node = nep.node(\"publisher_sample\"); pub = node.new_sub(\"matlab\", \"192.168.0.100\", 9090,\"one2many\"); msg = struct('message','hello','value',0); json_msg = jsonencode(msg); while 1 pub.publish(json_msg) pause(1) end See example 3 for more details of how to define the messages to send From MATLAB to MATLAB in different computer We can use the subscriber of example 2: import nep.node; node = nep.node(\"subscriber_sample\"); sub = node.new_sub(\"matlab\", \"192.168.0.100\", 9090,\"one2many\"); while 1 msg = sub.listen(); if strcmp(msg,\"{}\") pause(.00001) else value = jsondecode(string(msg)) end end and the publisher of example 4: import nep.node; node = nep.node(\"publisher_sample\"); pub = node.new_sub(\"matlab\", \"192.168.0.100\", 9090,\"one2many\"); msg = struct('message','hello','value',0); json_msg = jsonencode(msg); while 1 pub.publish(json_msg) pause(1) end Check examples 2 and 4 for more details. Just define the correct IP address and por value of your PCs (in this case IP = \"192.168.0.100\", port = 9090). Check python pub-sub for help.","title":"Examples"},{"location":"matlab_examples/#nep-in-matlab-examples","text":"NOTE: It is required matlab 2018b or above","title":"NEP in MATLAB: Examples"},{"location":"matlab_examples/#matlab-as-subscriber","text":"","title":"MATLAB as Subscriber"},{"location":"matlab_examples/#1-from-python-to-matlab-in-the-same-computer","text":"This example shows how a Subscriber node in MATLAB can read messages from a Publisher in Python. Both nodes are executed in the same computer It is required to execute the NEP Discovery Server before running the scripts of this example Being a Python publisher node publisher_sample connecting to the matlab topic and sending JSON messages as following: import nep import time import sys node = nep.node(\"publisher_sample\") pub = node.new_pub(\"matlab\",\"json\") while True: msg = data = {\"message\":\"hello\", \"value\":1.0} print (\"sending: \" + str(msg)) pub.publish(msg) time.sleep(1) The required subscriber in matlab can be defined as follow: import nep.node; node = nep.node(\"subscriber_sample\"); sub = node.new_sub(\"matlab\"); In order to read a message from a publisher we use the function msg = sub.listen(); However, this function is non-blocking, therefore if data is not available in the socket, then it will return \"{}\". Therefore, we need to add a conditional strcmp(msg,\"{}\") to ignore it when not messages are read. Then, we can also put the listen() function inside a loop as follow: while 1 msg = sub.listen(); if strcmp(msg,\"{}\") pause(.00001) else value = jsondecode(string(msg)) end end In this case when data is not read the program will wait .00001 seconds; otherwise, the value read will be shown as a MATLAB structure. Due that values returned by listen() are in Java string format, we need to use the functions string() and jsondecode() to transform from Java strings to MATLAB strings, and from MATLAB string to MATLAB structures respectively. The full MATLAB script is defined as: import nep.node; node = nep.node(\"subscriber_sample\"); sub = node.new_sub(\"matlab\"); while 1 msg = sub.listen(); if strcmp(msg,\"{}\") pause(.00001) else value = jsondecode(string(msg)) end end","title":"1.- From Python to MATLAB in the same computer"},{"location":"matlab_examples/#2-from-python-to-matlab-in-different-computer","text":"In order to communicate a Python publisher with a MATLAB subscriber running in different PC, we need to do some small changes to the code shown in example 1. Now the python script running the publisher can be defined as: import nep import time conf = node.direct(ip = \"192.168.0.100\", port = 9090, mode =\"one2many\") pub = node.new_pub(\"matlab\", \"json\", conf) while True: msg = data = {\"message\":\"hello\", \"value\":1.0} print (\"sending: \" + str(msg)) pub.publish(msg) time.sleep(1) Note that we change the next lines with respect publisher example 1: conf = node.direct(ip = \"192.168.0.100\", port = 9090, mode =\"one2many\") pub = node.new_pub(\"matlab\", \"json\", conf) which indicate that need to send messages from PC with IP address of 192.168.0.100 (change this value for the IP address of PC with Python) and port 9090 (This value must be the same in Python and MATLAB). More details in python pub-sub The MATLAB publisher able to communicate to this python script can be defined as: import nep.node; node = nep.node(\"subscriber_sample\"); sub = node.new_sub(\"matlab\", \"192.168.0.100\", 9090,\"one2many\"); while 1 msg = sub.listen(); if strcmp(msg,\"{}\") pause(.00001) else value = jsondecode(string(msg)) end end Check example 1 for more details.","title":"2.- From Python to MATLAB in different computer"},{"location":"matlab_examples/#matlab-as-a-publisher","text":"","title":"MATLAB as a publisher"},{"location":"matlab_examples/#3-from-matlab-to-python-in-the-same-computer","text":"This example shows how a Publisher node in MATLAB can communicate with a Subscriber in Python. Both nodes are executed in the same computer It is required to execute the NEP Discovery Server before running the script of this example Being a Python subscriber node subscriber_sample connecting to the matlab topic and reading JSON messages as following: import nep node = nep.node(\"subscriber_sample\") sub = node.new_sub(\"matlab\", \"json\") while True: s, msg = sub.listen() if s: # Info avaliable only if s == True print(str(msg)) The required publisher in matlab can be defined as follow: import nep.node; node = nep.node(\"publisher_sample\"); pub = node.new_pub(\"matlab\"); We need to define a message to send as a JSON value, for this we need to define a MATLAB structure. For example if we need to send the next JSON information: {\"message\":\"hello\", \"value\": 0} This can be defined in MATLAB with the next lines: msg = struct('message','hello','value',0) json_msg = jsonencode(msg) Where variable json_msg will contain the JSON message to send. In order to send the JSON messages to the subscriber, we can use the next line: pub.publish(json_msg) The full example of Publisher in MATLAB is shown bellow: import nep.node; node = nep.node(\"publisher_sample\"); pub = node.new_pub(\"matlab\"); msg = struct('message','hello','value',0); json_msg = jsonencode(msg); while 1 pub.publish(json_msg) pause(1) end","title":"3.- From MATLAB to Python in the same computer"},{"location":"matlab_examples/#4-from-matlab-to-python-in-different-computer","text":"In order to communicate a MATLAB publisher with a Python subscriber running in different PC, we need to do some small changes to the code shown in example 3. Now the python script running the subscriber can be defined as: import nep node = nep.node(\"subscriber_sample\") conf = node.direct(ip = \"127.0.0.1\", port = 9090, mode =\"one2many\") sub = node.new_sub(\"matlab\", \"json\", conf) while True: s, msg = sub.listen() if s: # Info avaliable only if s == True print(str(msg)) Note that we change the next lines with respect subscriber in example 3: conf = node.direct(ip = \"192.168.0.101\", port = 9090, mode =\"one2many\") sub = node.new_sub(\"matlab\", \"json\", conf) which indicate that need to read messages from PC with IP address of 192.168.0.100 (change this value for the IP address of PC with MATLAB) and port 9090 (This value must be the same in Python and MATLAB). More details in python pub-sub The MATLAB publisher able to communicate to this python script can be defined as: import nep.node; node = nep.node(\"publisher_sample\"); pub = node.new_sub(\"matlab\", \"192.168.0.100\", 9090,\"one2many\"); msg = struct('message','hello','value',0); json_msg = jsonencode(msg); while 1 pub.publish(json_msg) pause(1) end See example 3 for more details of how to define the messages to send","title":"4.- From MATLAB to Python in different computer"},{"location":"matlab_examples/#from-matlab-to-matlab-in-different-computer","text":"We can use the subscriber of example 2: import nep.node; node = nep.node(\"subscriber_sample\"); sub = node.new_sub(\"matlab\", \"192.168.0.100\", 9090,\"one2many\"); while 1 msg = sub.listen(); if strcmp(msg,\"{}\") pause(.00001) else value = jsondecode(string(msg)) end end and the publisher of example 4: import nep.node; node = nep.node(\"publisher_sample\"); pub = node.new_sub(\"matlab\", \"192.168.0.100\", 9090,\"one2many\"); msg = struct('message','hello','value',0); json_msg = jsonencode(msg); while 1 pub.publish(json_msg) pause(1) end Check examples 2 and 4 for more details. Just define the correct IP address and por value of your PCs (in this case IP = \"192.168.0.100\", port = 9090). Check python pub-sub for help.","title":"From MATLAB to MATLAB in different computer"},{"location":"nep/","text":"For non-programmers NEP is included in RIZE (Robot Programming From Zero Experience). This tool enables non-programmers to develop robot applications (links soon). Using pip For developers, nep can be conveniently installed using pip, just write the right commands in some terminal If you have only one version of Python (2 or 3) installed pip install nep pip install tornado For Python 2 also install: pip install trollius For Python 3 also install: pip install asyncio If you are in Windows and you have both Python 2 and Python 3 installed For Python 2: py -2 -m pip install -U nep py -2 -m pip install -U trollius py -2 -m pip install -U tornado For Python 3: py -3 -m pip install -U nep py -3 -m pip install -U asyncio py -3 -m pip install -U tornado If you are in OSX or Ubuntu and you have both Python 2 and Python 3 installed For Python 2: python2 -m pip install -U nep python2 -m pip install -U trollius python2 -m pip install -U tornado For Python 3: python3 -m pip install -U nep python3 -m pip install -U asyncio python3 -m pip install -U tornado Advanced installation options 1.- Back-end options The default back-end solution of NEP is ZeroMQ which is installed by default. Therefore no additional effort is needed to start to use it. The next table describes the installation complexity of other back-ends supported by NEP. Middleware Windows Linux Mac OS X Drawbacks nanomsg Easy Very complex Very complex Binaries must be compiled in many cases ROS N.A Complex N.A ROS do not fully supports Windows and Mac OS X ROS 2.0 Very complex Complex Complex ROS 2.0 only supports Windows 10, few version of Ubuntu and MacOS X (10.14 Mojave still not supported) NEP using ZeroMQ as back-end has been tested with success in Windows 7, 8, 8.1 and 10, Ubuntu 16.04, 16.10, 18.04 and 18.10, as well as Mac OS X latest versions, including Mojave (10.14). 2.- Using ROS Follow steps for intall ROS from official documentation ROS installation details 3.- Using ROS 2.0 Follow steps for intall ROS 2.0 from official documentation ROS 2.0 installation details 4.- Using Nanomsg Pre-compiled binaries for Windows - download here 5.- Github 5.1 Old version (0.1) NEP Beta version (warning: older presents a different API and fewer capabilities): Link to older version @incollection{coronado2019design, title={Design of a Human-Centered Robot Framework for End-User Programming and Applications}, author={Coronado, Enrique and Mastrogiovanni, Fulvio and Venture, Gentiane}, booktitle={ROMANSY 22--Robot Design, Dynamics and Control}, pages={450--457}, year={2019}, publisher={Springer} } 5.2 Current version (1.0) Link to current version","title":"Install NEP"},{"location":"nep/#for-non-programmers","text":"NEP is included in RIZE (Robot Programming From Zero Experience). This tool enables non-programmers to develop robot applications (links soon).","title":"For non-programmers"},{"location":"nep/#using-pip","text":"For developers, nep can be conveniently installed using pip, just write the right commands in some terminal If you have only one version of Python (2 or 3) installed pip install nep pip install tornado For Python 2 also install: pip install trollius For Python 3 also install: pip install asyncio If you are in Windows and you have both Python 2 and Python 3 installed For Python 2: py -2 -m pip install -U nep py -2 -m pip install -U trollius py -2 -m pip install -U tornado For Python 3: py -3 -m pip install -U nep py -3 -m pip install -U asyncio py -3 -m pip install -U tornado If you are in OSX or Ubuntu and you have both Python 2 and Python 3 installed For Python 2: python2 -m pip install -U nep python2 -m pip install -U trollius python2 -m pip install -U tornado For Python 3: python3 -m pip install -U nep python3 -m pip install -U asyncio python3 -m pip install -U tornado","title":"Using pip"},{"location":"nep/#advanced-installation-options","text":"","title":"Advanced installation options"},{"location":"nep/#1-back-end-options","text":"The default back-end solution of NEP is ZeroMQ which is installed by default. Therefore no additional effort is needed to start to use it. The next table describes the installation complexity of other back-ends supported by NEP. Middleware Windows Linux Mac OS X Drawbacks nanomsg Easy Very complex Very complex Binaries must be compiled in many cases ROS N.A Complex N.A ROS do not fully supports Windows and Mac OS X ROS 2.0 Very complex Complex Complex ROS 2.0 only supports Windows 10, few version of Ubuntu and MacOS X (10.14 Mojave still not supported) NEP using ZeroMQ as back-end has been tested with success in Windows 7, 8, 8.1 and 10, Ubuntu 16.04, 16.10, 18.04 and 18.10, as well as Mac OS X latest versions, including Mojave (10.14).","title":"1.- Back-end options"},{"location":"nep/#2-using-ros","text":"Follow steps for intall ROS from official documentation ROS installation details","title":"2.- Using ROS"},{"location":"nep/#3-using-ros-20","text":"Follow steps for intall ROS 2.0 from official documentation ROS 2.0 installation details","title":"3.- Using ROS 2.0"},{"location":"nep/#4-using-nanomsg","text":"Pre-compiled binaries for Windows - download here","title":"4.- Using Nanomsg"},{"location":"nep/#5-github","text":"","title":"5.- Github"},{"location":"nep/#51-old-version-01","text":"NEP Beta version (warning: older presents a different API and fewer capabilities): Link to older version @incollection{coronado2019design, title={Design of a Human-Centered Robot Framework for End-User Programming and Applications}, author={Coronado, Enrique and Mastrogiovanni, Fulvio and Venture, Gentiane}, booktitle={ROMANSY 22--Robot Design, Dynamics and Control}, pages={450--457}, year={2019}, publisher={Springer} }","title":"5.1 Old version (0.1)"},{"location":"nep/#52-current-version-10","text":"Link to current version","title":"5.2 Current version (1.0)"},{"location":"nep_discovery/","text":"From installers In order to enable Hybrid P2P architectures using ZeroMQ or nanomsg (more info in Introduction to Software Architectures for Robotics ), the NEP Discovery Server must to be installed and executed. NEP Discovery Windows NEP Discovery OSX NEP Discovery Ubuntu","title":"Install Discovery Server"},{"location":"nep_discovery/#from-installers","text":"In order to enable Hybrid P2P architectures using ZeroMQ or nanomsg (more info in Introduction to Software Architectures for Robotics ), the NEP Discovery Server must to be installed and executed. NEP Discovery Windows NEP Discovery OSX NEP Discovery Ubuntu","title":"From installers"},{"location":"publish/","text":"In a Publish-Subscribe pattern, a producer of messages (publisher) send messages without knowing if any receiver (subscriber) exists. Two option have expressed this tutorial: Option 1: using fixed IP and port values (for very simple architectures) Option 2: Using a ROS, ROS2.0, ZMQ and nanomsg reusable architectures Options 1 can be enough when the problem to solve requires only to connect two processes that run, for example, in different machines or in different versions of Python (2 and 3). However, if it needs to have more lost-lasting, and reusable code, option 2 is better suited. 1.- Using fixed IP and port values A simple publisher node can be defined as: import nep import time # Create a new node node = nep.node(\"publisher_sample\") # Select the configuration of the publisher conf = node.direct(ip = \"127.0.0.1\", port = 9090, mode =\"one2many\") # Set the topic and the configuration of the publisher pub = node.new_pub(\"pub_sub_test\",\"json\",conf) # Publish a message each second while True: msg = {\"info\":\"hello\"} pub.publish(msg) time.sleep(1) First we need to create a new nep.node instance with is denoted as node . The we define the type of architecture to use in the line: conf = node.direct(ip = \"127.0.0.1\", port = 9090, mode =\"one2many\") This line defines the IP address and port of the publisher to create, as well as the type of publisher, which can be \"one2many\" or many2one . On the one hand, in the \"one2many\" mode only one publisher can send messages an undefined number of subscribers. On the other hand, in the \"many2one\" mode an undefined number of publishers can send information to just one subscriber. WARNING 1: Nodes with different modes (one2many or many2one) cannot be communicated between them. WARNING 2: It is not possible to execute more than one \"one2many\" publishers that have the same IP and port values. WARNING 3: It is not possible to execute more than one \"many2one\" subscribers that have the same IP and port values. Then we need to define a new publisher instance using the new_pub function. In this function, we need to define a topic name (message identifier), the type of message (\"json\" or \"string\") and the configuration of the publisher. In this case, the topic is defined with the name of pub_sub_test and the message type is json (which enables the use of python dictionaries). We also select the configuration value defined in conf variable. The created publisher is then defined in the pub instance. Finally, a message defined as a python dictionary is sent each second using the publish function of the pub instance. The subcriber node able to read the messages of the publisher defined before can be defined as: import nep # Function executed each time gets a new message def mycallback(msg): print (msg) # Print message # Use here msg for some operation ... # Create a new node node = nep.node(\"subscriber_sample\") # Select the configuration of the subscriber conf = node.direct(ip = \"127.0.0.1\", port = 9090, mode =\"one2many\") # Define a new subcriber using a callback function sub = node.new_callback(\"pub_sub_test\", \"json\" , mycallback, conf) node.spin() In this example, we use a function denoted as mycallback , which is executed in a different thread and that be executed each time a new message is read by the subscriber. The configuration set to the subscriber must be the same that the publisher. In this case, we use the function new_callback to create the subscriber instance. This function requires the same topic name defined in the subscriber ( \"pub_sub_test\" ), the type of message to receive ( \"json\" ), the function that will be executed each time a message arrives ( mycallback ), and the subscriber configuration defined in conf . Communication between different PCs Different computers using different operating systems can be connected using a direct network configuration. These devices need to be connected to the same network and specify the IP address of one of the PCs in the network and the same port. The IP value will depend on the publish-subscribe configuration mode. .tg {border-collapse:collapse;border-spacing:0;} .tg td{font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:1px;overflow:hidden;word-break:normal;border-color:black;} .tg th{font-family:Arial, sans-serif;font-size:14px;font-weight:normal;padding:10px 5px;border-style:solid;border-width:1px;overflow:hidden;word-break:normal;border-color:black;} .tg .tg-h8bj{font-weight:bold;background-color:#c0c0c0;color:#333333;border-color:inherit;text-align:center;vertical-align:top} .tg .tg-us36{border-color:inherit;vertical-align:top} .tg .tg-00jj{font-style:italic;border-color:inherit;vertical-align:top} Mode Set the IP value of one2many Publisher node many2one Subscriber node For example, if a one2many publisher node in a PC with IP 192.168.11.1 need to communicate with a Subscriber node in other PC with IP 192.168.11.2 , the configuration of the publisher in port 10090 must be: conf = node.direct(ip = \"192.168.11.1\", port = 10090, mode =\"one2many\") and subscriber configuration must be as follow: conf = node.direct(ip = \"192.168.11.1\", port = 10090, mode =\"one2many\") 2.- ROS, ROS2, ZMQ and nanomsg reusable architectures","title":"Publish-Subscribe"},{"location":"publish/#1-using-fixed-ip-and-port-values","text":"A simple publisher node can be defined as: import nep import time # Create a new node node = nep.node(\"publisher_sample\") # Select the configuration of the publisher conf = node.direct(ip = \"127.0.0.1\", port = 9090, mode =\"one2many\") # Set the topic and the configuration of the publisher pub = node.new_pub(\"pub_sub_test\",\"json\",conf) # Publish a message each second while True: msg = {\"info\":\"hello\"} pub.publish(msg) time.sleep(1) First we need to create a new nep.node instance with is denoted as node . The we define the type of architecture to use in the line: conf = node.direct(ip = \"127.0.0.1\", port = 9090, mode =\"one2many\") This line defines the IP address and port of the publisher to create, as well as the type of publisher, which can be \"one2many\" or many2one . On the one hand, in the \"one2many\" mode only one publisher can send messages an undefined number of subscribers. On the other hand, in the \"many2one\" mode an undefined number of publishers can send information to just one subscriber. WARNING 1: Nodes with different modes (one2many or many2one) cannot be communicated between them. WARNING 2: It is not possible to execute more than one \"one2many\" publishers that have the same IP and port values. WARNING 3: It is not possible to execute more than one \"many2one\" subscribers that have the same IP and port values. Then we need to define a new publisher instance using the new_pub function. In this function, we need to define a topic name (message identifier), the type of message (\"json\" or \"string\") and the configuration of the publisher. In this case, the topic is defined with the name of pub_sub_test and the message type is json (which enables the use of python dictionaries). We also select the configuration value defined in conf variable. The created publisher is then defined in the pub instance. Finally, a message defined as a python dictionary is sent each second using the publish function of the pub instance. The subcriber node able to read the messages of the publisher defined before can be defined as: import nep # Function executed each time gets a new message def mycallback(msg): print (msg) # Print message # Use here msg for some operation ... # Create a new node node = nep.node(\"subscriber_sample\") # Select the configuration of the subscriber conf = node.direct(ip = \"127.0.0.1\", port = 9090, mode =\"one2many\") # Define a new subcriber using a callback function sub = node.new_callback(\"pub_sub_test\", \"json\" , mycallback, conf) node.spin() In this example, we use a function denoted as mycallback , which is executed in a different thread and that be executed each time a new message is read by the subscriber. The configuration set to the subscriber must be the same that the publisher. In this case, we use the function new_callback to create the subscriber instance. This function requires the same topic name defined in the subscriber ( \"pub_sub_test\" ), the type of message to receive ( \"json\" ), the function that will be executed each time a message arrives ( mycallback ), and the subscriber configuration defined in conf .","title":"1.- Using fixed IP and port values"},{"location":"publish/#communication-between-different-pcs","text":"Different computers using different operating systems can be connected using a direct network configuration. These devices need to be connected to the same network and specify the IP address of one of the PCs in the network and the same port. The IP value will depend on the publish-subscribe configuration mode. .tg {border-collapse:collapse;border-spacing:0;} .tg td{font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:1px;overflow:hidden;word-break:normal;border-color:black;} .tg th{font-family:Arial, sans-serif;font-size:14px;font-weight:normal;padding:10px 5px;border-style:solid;border-width:1px;overflow:hidden;word-break:normal;border-color:black;} .tg .tg-h8bj{font-weight:bold;background-color:#c0c0c0;color:#333333;border-color:inherit;text-align:center;vertical-align:top} .tg .tg-us36{border-color:inherit;vertical-align:top} .tg .tg-00jj{font-style:italic;border-color:inherit;vertical-align:top} Mode Set the IP value of one2many Publisher node many2one Subscriber node For example, if a one2many publisher node in a PC with IP 192.168.11.1 need to communicate with a Subscriber node in other PC with IP 192.168.11.2 , the configuration of the publisher in port 10090 must be: conf = node.direct(ip = \"192.168.11.1\", port = 10090, mode =\"one2many\") and subscriber configuration must be as follow: conf = node.direct(ip = \"192.168.11.1\", port = 10090, mode =\"one2many\")","title":"Communication between different PCs"},{"location":"publish/#2-ros-ros2-zmq-and-nanomsg-reusable-architectures","text":"","title":"2.- ROS, ROS2, ZMQ and nanomsg reusable architectures"},{"location":"python/","text":"Important information for users The first step is to install Python in your computer, we need to select between Python 2 (recommended) or Python 3. Install Python 2 if you are using the next robots: Nao Pepper Install Python 3 if you are using: Vector Cozmo Important information for developers We highly recommend using the official installers of Python from its official web . For programming in Python and many other languages we recommend Visual Studio Code . Windows Install Python 2 correctly in Windows 1.- Go to the official Python 2 download page 2.- Download Windows x86 MSI installer . Be sure that is the x86 (32 bits) version. 3.- Execute the installer downloaded 4.- Very important : when reaching the interface shown below, be sure of activate Add python.exe to Path - Will be installed on local hard drive . 5.- Continue and finish the installation Install Python 3 correctly in Windows (not ROS 2.0) 1.- Go to the official Python 3 download page 2.- Download the lastest Python 3 version 3.- Execute the installer downloaded 4.- Very important : when reaching next interface 5.- Continue and finish the installation Install Python 3 for use ROS 2.0 in Windows Follow ROS 2.0 instructions avaliables here . Mac OS X Install Python 2 in MacOS The next steps enable the use of NAO and Pepper robots on OSX Go to the official Python 2 download page . Download macOS 64-bit installer, execute this installer and follow the wizard using the default options. Install Python 3 MacOS Install HomeBrew as indicated in Homebrew official page . Open a macOS Terminal prompt and write: brew update brew install python3","title":"Install Python"},{"location":"python/#important-information-for-users","text":"The first step is to install Python in your computer, we need to select between Python 2 (recommended) or Python 3. Install Python 2 if you are using the next robots: Nao Pepper Install Python 3 if you are using: Vector Cozmo","title":"Important information for users"},{"location":"python/#important-information-for-developers","text":"We highly recommend using the official installers of Python from its official web . For programming in Python and many other languages we recommend Visual Studio Code .","title":"Important information for developers"},{"location":"python/#windows","text":"","title":"Windows"},{"location":"python/#install-python-2-correctly-in-windows","text":"1.- Go to the official Python 2 download page 2.- Download Windows x86 MSI installer . Be sure that is the x86 (32 bits) version. 3.- Execute the installer downloaded 4.- Very important : when reaching the interface shown below, be sure of activate Add python.exe to Path - Will be installed on local hard drive . 5.- Continue and finish the installation","title":"Install Python 2 correctly in Windows"},{"location":"python/#install-python-3-correctly-in-windows-not-ros-20","text":"1.- Go to the official Python 3 download page 2.- Download the lastest Python 3 version 3.- Execute the installer downloaded 4.- Very important : when reaching next interface 5.- Continue and finish the installation","title":"Install Python 3 correctly in Windows (not ROS 2.0)"},{"location":"python/#install-python-3-for-use-ros-20-in-windows","text":"Follow ROS 2.0 instructions avaliables here .","title":"Install Python 3 for use ROS 2.0 in Windows"},{"location":"python/#mac-os-x","text":"","title":"Mac OS X"},{"location":"python/#install-python-2-in-macos","text":"The next steps enable the use of NAO and Pepper robots on OSX Go to the official Python 2 download page . Download macOS 64-bit installer, execute this installer and follow the wizard using the default options.","title":"Install Python 2 in MacOS"},{"location":"python/#install-python-3-macos","text":"Install HomeBrew as indicated in Homebrew official page . Open a macOS Terminal prompt and write: brew update brew install python3","title":"Install Python 3 MacOS"},{"location":"python3/","text":"Windows 1.- Go to the official Python 3 download page . 2.- Download the lastest Python 3 version 3.- Execute the downloaded installer. 4.- Very important : when reaching next interface be sure of activate * Add python 3.7 to PATH 5.- Continue and finish the installation Windows using ROS 2.0 Follow ROS 2.0 instructions avaliables here . MacOS (for use Cozmo and Vector robots or ROS 2.0) Install HomeBrew as indicated in Homebrew official page . Open a macOS Terminal prompt and write: brew update brew install python3 If you installed Python as described in our tutorial to install Python , then you can install NEP using the next Nep Installer program. Download and execute the NEP Installer program. Windows and OSX users: Computer must be connect to internet while installing NEP library for Python NEP Windows NEP OSX Ubuntu users: This installers just run the right pip install command for you. Because Ubuntu requires superuser password, there is not end-user installer in this platform. To install NEP python library just press the button of the version of Python installed in your PC.","title":"Python 3 recommended installation way"},{"location":"python3/#windows","text":"1.- Go to the official Python 3 download page . 2.- Download the lastest Python 3 version 3.- Execute the downloaded installer. 4.- Very important : when reaching next interface be sure of activate * Add python 3.7 to PATH 5.- Continue and finish the installation","title":"Windows"},{"location":"python3/#windows-using-ros-20","text":"Follow ROS 2.0 instructions avaliables here .","title":"Windows using ROS 2.0"},{"location":"python3/#macos-for-use-cozmo-and-vector-robots-or-ros-20","text":"Install HomeBrew as indicated in Homebrew official page . Open a macOS Terminal prompt and write: brew update brew install python3 If you installed Python as described in our tutorial to install Python , then you can install NEP using the next Nep Installer program. Download and execute the NEP Installer program. Windows and OSX users: Computer must be connect to internet while installing NEP library for Python NEP Windows NEP OSX Ubuntu users: This installers just run the right pip install command for you. Because Ubuntu requires superuser password, there is not end-user installer in this platform. To install NEP python library just press the button of the version of Python installed in your PC.","title":"MacOS (for use Cozmo and Vector robots or ROS 2.0)"},{"location":"server/","text":"In the Client-Server pattern a node (client) sends a request of some data to other node (server). The execution of the client node blocks its execution until a response is send by the server. Examples of client-server applications are shown bellow. Using fixed IP and port When simple applications with few nodes are needed a fixed endpoint value (IP and port) can be enough Simple client In the Client-Server pattern, a node (client) sends a request of some data to another node (server). The execution of the client node blocks its execution until a response is sent by the server. Examples of client-server applications are shown below. Using fixed IP and port When simple applications with few nodes are needed a fixed endpoint value (IP and port) can be enough Simple client A simple client node asking each 2 seconds for some information can be defined as: import nep import time client = nep.client('127.0.0.1', 8014) # Create a new client instance while True: msg = {\"message\":\"client request\"} # Message to send as request client.send_info(msg) # Send request print (client.listen_info()) # Wait for server response time.sleep(2) # Wait one second In this example a new instance of the nep.client class is created with the line: client = nep.client('127.0.0.1', 8014) For this, the IP and PORT parameters are defined as '127.0.0.1' and 8014 respectively. The function send_info can be used to send a request to the server. This request must be defined as a python dictionary. In this case the dictionary {\"message\":\"client request\"} is defined to be send a request. The function listen_info waits until the server sends its response. This function also reads the message sent by the server. Simple server The next Python script shows a simple example of a server node. import nep # Import nep library server = nep.server('127.0.0.1', 8014) #Create a new server instance while True: request = server.listen_info() # Wait for client request server.send_info({\"message\":\"hello client\"}) # Send server response print (request) In this example a new instance of the server.nep class is created with the line: server = nep.server('127.0.0.1', 8014) We need to define the same IP and PORT values in the client node. The functions listen_info and send_info can be used to read a client request and send a response, respectively. In this example the response to be sent in defined as {\"message\":\"hello client\"} . Using default Python sockets The client and server classes of NEP use ZeroMQ by default (sockets with steroids). However, an optional parameter can be used to select the socket type. To use TCP/IP POSIX sockets, a client with a port value of 30000 can be defined as: client = nep.client('127.0.0.1', 30000, 'normal') However, instead of dictionaries, messages must be sent as a string. A full example is shown below: import nep import time client = nep.client('127.0.0.1', 30000, 'normal') # Create a new client instance while True: msg = \"hello server\" # Message to send as request client.send_info(msg) # Send request print (client.listen_info()) # Wait for server response time.sleep(1) # Wait one second The server node used to response the client requests can be defined as: import nep # Import nep library server = nep.server('127.0.0.1', 30000, 'normal') #Create a new server instance while True: request = server.listen_info() # Wait for client request print (request) server.send_info(\"server response\") # Send server response In this case it is also needed to define the socket types as normal as shown bellow: server = nep.server('127.0.0.1', 30000, 'normal') WARNING: It is not possible to communicate a ZeroMQ socket and a typical TCP/IP POSIX socket Using NEP master When the number of nodes increases the management of IP and port values becomes a tedious task. In order to avoid this problem NEP nodes using the client/server pattern can be managed by the NEP master. An example of a client connected through NEP master is shown below: import nep import time node = nep.node(\"client_test\") # New nep node client = node.new_client(\"client_server_sample\") # Topic while True: msg = {\"message\":\"client request\"} # Message to send as request client.send_info(msg) # Send request print (client.listen_info()) # Wait for server response time.sleep(1) # Wait one second However, the way to define the client presents some differences. First, we need to create a nep.node instance and specify a unique name for this node, in this case, that name is defined as \"client_test\" . Then, it is required to start a new client instance using the new_client() function. It is also needs to define a name for the client. This name, denoted as topic, will be used by the NEP master to assign some suitable IP and port values to the client instance. In this case, the topic is defined as \"client_server_sample\" . The server is defined similarly but using the new_server() function as shown in the next example: import nep # Import nep library node = nep.node(\"server_test\") # New nep node server = node.new_server(\"client_server_sample\") # Topic while True: msg = {\"message\":\"hello\"} # Message to send as response request = server.listen_info() # Wait for client request server.send_info(msg) # Send server response print (request) WARNING: NEP master must be first started to use these last two examples","title":"Client-Server"},{"location":"server/#using-fixed-ip-and-port","text":"When simple applications with few nodes are needed a fixed endpoint value (IP and port) can be enough","title":"Using fixed IP and port"},{"location":"server/#simple-client","text":"In the Client-Server pattern, a node (client) sends a request of some data to another node (server). The execution of the client node blocks its execution until a response is sent by the server. Examples of client-server applications are shown below.","title":"Simple client"},{"location":"server/#using-fixed-ip-and-port_1","text":"When simple applications with few nodes are needed a fixed endpoint value (IP and port) can be enough","title":"Using fixed IP and port"},{"location":"server/#simple-client_1","text":"A simple client node asking each 2 seconds for some information can be defined as: import nep import time client = nep.client('127.0.0.1', 8014) # Create a new client instance while True: msg = {\"message\":\"client request\"} # Message to send as request client.send_info(msg) # Send request print (client.listen_info()) # Wait for server response time.sleep(2) # Wait one second In this example a new instance of the nep.client class is created with the line: client = nep.client('127.0.0.1', 8014) For this, the IP and PORT parameters are defined as '127.0.0.1' and 8014 respectively. The function send_info can be used to send a request to the server. This request must be defined as a python dictionary. In this case the dictionary {\"message\":\"client request\"} is defined to be send a request. The function listen_info waits until the server sends its response. This function also reads the message sent by the server.","title":"Simple client"},{"location":"server/#simple-server","text":"The next Python script shows a simple example of a server node. import nep # Import nep library server = nep.server('127.0.0.1', 8014) #Create a new server instance while True: request = server.listen_info() # Wait for client request server.send_info({\"message\":\"hello client\"}) # Send server response print (request) In this example a new instance of the server.nep class is created with the line: server = nep.server('127.0.0.1', 8014) We need to define the same IP and PORT values in the client node. The functions listen_info and send_info can be used to read a client request and send a response, respectively. In this example the response to be sent in defined as {\"message\":\"hello client\"} .","title":"Simple server"},{"location":"server/#using-default-python-sockets","text":"The client and server classes of NEP use ZeroMQ by default (sockets with steroids). However, an optional parameter can be used to select the socket type. To use TCP/IP POSIX sockets, a client with a port value of 30000 can be defined as: client = nep.client('127.0.0.1', 30000, 'normal') However, instead of dictionaries, messages must be sent as a string. A full example is shown below: import nep import time client = nep.client('127.0.0.1', 30000, 'normal') # Create a new client instance while True: msg = \"hello server\" # Message to send as request client.send_info(msg) # Send request print (client.listen_info()) # Wait for server response time.sleep(1) # Wait one second The server node used to response the client requests can be defined as: import nep # Import nep library server = nep.server('127.0.0.1', 30000, 'normal') #Create a new server instance while True: request = server.listen_info() # Wait for client request print (request) server.send_info(\"server response\") # Send server response In this case it is also needed to define the socket types as normal as shown bellow: server = nep.server('127.0.0.1', 30000, 'normal') WARNING: It is not possible to communicate a ZeroMQ socket and a typical TCP/IP POSIX socket","title":"Using default Python sockets"},{"location":"server/#using-nep-master","text":"When the number of nodes increases the management of IP and port values becomes a tedious task. In order to avoid this problem NEP nodes using the client/server pattern can be managed by the NEP master. An example of a client connected through NEP master is shown below: import nep import time node = nep.node(\"client_test\") # New nep node client = node.new_client(\"client_server_sample\") # Topic while True: msg = {\"message\":\"client request\"} # Message to send as request client.send_info(msg) # Send request print (client.listen_info()) # Wait for server response time.sleep(1) # Wait one second However, the way to define the client presents some differences. First, we need to create a nep.node instance and specify a unique name for this node, in this case, that name is defined as \"client_test\" . Then, it is required to start a new client instance using the new_client() function. It is also needs to define a name for the client. This name, denoted as topic, will be used by the NEP master to assign some suitable IP and port values to the client instance. In this case, the topic is defined as \"client_server_sample\" . The server is defined similarly but using the new_server() function as shown in the next example: import nep # Import nep library node = nep.node(\"server_test\") # New nep node server = node.new_server(\"client_server_sample\") # Topic while True: msg = {\"message\":\"hello\"} # Message to send as response request = server.listen_info() # Wait for client request server.send_info(msg) # Send server response print (request) WARNING: NEP master must be first started to use these last two examples","title":"Using NEP master"},{"location":"theory/","text":"Nodes and inter-process communication In order to reduce the effort required to generate more complex robotic systems, robot applications must be divided into a set of simple and interchangeable processes, also denoted as nodes . The ways in which different nodes communicate between them is denoted as inter-process communication . There exist different inter-process communication options. However, the most extended approach on Robotics is sockets . The idea of separate a robot application in simple nodes has the main objective to improve the reusability, maintainability and performance of robotic systems. This approach implies to start thinking in a \"divide and conquer\" way. Sockets and robot middlewares Sockets are commonly used when: (i) communication between nodes on the same machine is needed or (ii) communication between nodes on different machines or devices is needed. These nodes can be written on different programming language as long as share the same protocol and serialization approach. A socket is mainly defined by an endpoint which is composed by a protocol, an ip address and a port value. An example of endpoint definition is tcp://127.0.0.1:5000 , where tcp indicates the protocol, 127.0.0.1 indicates local ip address and 5000 is the port of the connection. A typical solution adopted to create distributed robotic systems using sockets is messaging middlewares. NEP uses ZeroMQ, nanomsg, ROS and ROS 2.0 back-end messaging middleware libraries. The approach adopted in NEP is to keep the code independent of the middleware or transport layer in order to enable an ease switch to future technologies. Comunication patterns Messaging patterns are generally used to describes the flow of communication between a process in distributed systems. Two widely used messaging patterns in robotics are Request/Process/Reply and Publish/Subscribe . Request/Process/Reply In the Request/Process/Reply pattern, also denoted as client/server , a process sends a request for some data and then waits for the response to this request. However, if a response never comes a deadlock can occur (i.e a read operation cannot be performed when a write operation is in progress, and vice versa). This pattern is good for the cases where synchronization between two tasks is needed. Publish-Subscribe The publish/subscribe model is another classic pattern where the producers of messages, called publishers, send messages without the knowledge of what or if any receiver, called subscribers. Unlike typical client/server models, the communication in a publish/subscribe model is generally done in an asynchronous way. Most popular publish/subscribe schemes are based on the notion of topics . In this scheme, subscribers can use a set of keywords called topics to filter the information sent by publishers. Network architectures Network architectures used to create distributed systems are characterized by a number of trade-offs that involve efficiency, determinism, scalability, security and robustness. NEP supports multiple network architectures which include direct endpoint descriptions , Hybrid Peer to Peer (P2P) master server . A description of each approach is shown bellow. In a direct endpoint descriptions architecture the endpoints are manually set by the user. However, this approach must be avoided when many processes need to be connected between them or when it is expected to scale the number of nodes in the future. This is due that the manageability of the system gets worse when the number of nodes increases. When using a Hybrid P2P architecture all the nodes in the network are implicitly connected to some node denoted as master name server , which performs the management of endpoints using a set of identifiers called topics . When the master node detects a topic registration request from some node, it assigns to the requested topic an endpoint direction (i.e., an IP address and a port). This endpoint information is saved and sent to the instances which have performed the registration request of the topic (e.g. a publisher or a subscriber). In this approach, communication starts when at least one producer ( e.g. a publisher) and one receiver (e.g. a subscriber) have requested the registration of the same topic. This approach reduces manageability problems but is considered a single point of failure due that if the master name server accidentally crashes or stops, new communication between nodes will be not possible. This approach is used in ROS and by the NEP Discovery Server.","title":"Introduction to Software Architectures for Robotics"},{"location":"theory/#nodes-and-inter-process-communication","text":"In order to reduce the effort required to generate more complex robotic systems, robot applications must be divided into a set of simple and interchangeable processes, also denoted as nodes . The ways in which different nodes communicate between them is denoted as inter-process communication . There exist different inter-process communication options. However, the most extended approach on Robotics is sockets . The idea of separate a robot application in simple nodes has the main objective to improve the reusability, maintainability and performance of robotic systems. This approach implies to start thinking in a \"divide and conquer\" way.","title":"Nodes and inter-process communication"},{"location":"theory/#sockets-and-robot-middlewares","text":"Sockets are commonly used when: (i) communication between nodes on the same machine is needed or (ii) communication between nodes on different machines or devices is needed. These nodes can be written on different programming language as long as share the same protocol and serialization approach. A socket is mainly defined by an endpoint which is composed by a protocol, an ip address and a port value. An example of endpoint definition is tcp://127.0.0.1:5000 , where tcp indicates the protocol, 127.0.0.1 indicates local ip address and 5000 is the port of the connection. A typical solution adopted to create distributed robotic systems using sockets is messaging middlewares. NEP uses ZeroMQ, nanomsg, ROS and ROS 2.0 back-end messaging middleware libraries. The approach adopted in NEP is to keep the code independent of the middleware or transport layer in order to enable an ease switch to future technologies.","title":"Sockets and robot middlewares"},{"location":"theory/#comunication-patterns","text":"Messaging patterns are generally used to describes the flow of communication between a process in distributed systems. Two widely used messaging patterns in robotics are Request/Process/Reply and Publish/Subscribe .","title":"Comunication patterns"},{"location":"theory/#requestprocessreply","text":"In the Request/Process/Reply pattern, also denoted as client/server , a process sends a request for some data and then waits for the response to this request. However, if a response never comes a deadlock can occur (i.e a read operation cannot be performed when a write operation is in progress, and vice versa). This pattern is good for the cases where synchronization between two tasks is needed.","title":"Request/Process/Reply"},{"location":"theory/#publish-subscribe","text":"The publish/subscribe model is another classic pattern where the producers of messages, called publishers, send messages without the knowledge of what or if any receiver, called subscribers. Unlike typical client/server models, the communication in a publish/subscribe model is generally done in an asynchronous way. Most popular publish/subscribe schemes are based on the notion of topics . In this scheme, subscribers can use a set of keywords called topics to filter the information sent by publishers.","title":"Publish-Subscribe"},{"location":"theory/#network-architectures","text":"Network architectures used to create distributed systems are characterized by a number of trade-offs that involve efficiency, determinism, scalability, security and robustness. NEP supports multiple network architectures which include direct endpoint descriptions , Hybrid Peer to Peer (P2P) master server . A description of each approach is shown bellow. In a direct endpoint descriptions architecture the endpoints are manually set by the user. However, this approach must be avoided when many processes need to be connected between them or when it is expected to scale the number of nodes in the future. This is due that the manageability of the system gets worse when the number of nodes increases. When using a Hybrid P2P architecture all the nodes in the network are implicitly connected to some node denoted as master name server , which performs the management of endpoints using a set of identifiers called topics . When the master node detects a topic registration request from some node, it assigns to the requested topic an endpoint direction (i.e., an IP address and a port). This endpoint information is saved and sent to the instances which have performed the registration request of the topic (e.g. a publisher or a subscriber). In this approach, communication starts when at least one producer ( e.g. a publisher) and one receiver (e.g. a subscriber) have requested the registration of the same topic. This approach reduces manageability problems but is considered a single point of failure due that if the master name server accidentally crashes or stops, new communication between nodes will be not possible. This approach is used in ROS and by the NEP Discovery Server.","title":"Network architectures"}]}